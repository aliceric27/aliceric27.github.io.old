---
title: 什麼是閉包 (Closure)？
date: 2024-09-06 14:22:06
tags:
  - [Front-end]
categories:
  - [Front-end]
---

閉包 (closure) 是程式語言的一種特性，在 JavaScript 中也扮演相當重要的角色，被廣泛應用在 JavaScript 程式庫中。許多被開發者大量使用的重要功能，也都看得到閉包的身影，舉例來說最熱門的 JavaScript 函式庫 React 中的 useState 就是透過閉包來實作。

<!-- more -->

------

## 什麼是[閉包](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Closures)

閉包和作用域相關，首先要先瞭解[hoisting概念](https://blog.huli.tw/2018/11/10/javascript-hoisting-and-tdz/)，就會比較好懂閉包邏輯。
簡單說就是在同作用域下可以存取到對應作用域變數的意思。

{% note info%}舉例
以下是一個最簡單的例子，在下方程式碼中的`inner`函式，能拿到外部函式`outer`的`a`變數，並將其保存在記憶體中。
當我們呼叫 inner 時，之所以不是每次都回傳 1 ，而是回傳 1、2、3 不斷加上去，正是因為之前的`a`的狀態被記住了。
因為`inner`內部讀取的 a 變數，是在作用域外的這個 a 變數，同理`console.log(a)`，此時也會往外去尋找`a`變數的值。
{% endnote %}

```js
function outer() {
  let a = 0;
  function inner() {
    a += 1;
    console.log(a);
  }
  return inner;
}

const inner = outer();

inner(); // 1
inner(); // 2
inner(); // 3
```

## 閉包的應用 1 — 狀態保存

在寫程式時，我們很常會需要記住某個狀態，JavaScript 的熱門函式庫 React 就有提供一個`useState`讓開發者來管理狀態。以下我們模擬一個簡化版的`useState`，可以在下方的程式碼看到，`getState`與`setState`作為內部函式，可以取得外部函式當中的 state，在實際呼叫後，如果這個 state 有改變，`getState`可以持續取得最新改變的值。

```js
// 因為閉包的關係，getState 與 setState 可以取得與記得 state
function useState(initState) {
  let state = initState; // 初始參數

  function getState() {
    return state;
  }

  function setState(updatedState) {
    state = updatedState;
  }
  return [getState, setState];
}

const [count, setCount] = useState(0);

count(); // 0
setCount(1);
count(); // 1
setCount(500);
count(); // 500
```

## 閉包的應用 2：緩存機制

因為閉包可以讓內部函式記住外部的變數，我們可以依照這個特性，透過閉包來實現緩存機制。以下面的例子來說，因為閉包原理，`cache`變數可以被回傳的箭頭函式取得與記得，所以我們能夠重複用`cache`來放想要緩存的東西。

## 閉包的應用 3：模擬私有變數
許多程式語言有宣告私有方法的語法，這些私有變數對於外部來講是隱藏的，這是一項很重要的特性，因為有時候我們在開發的程式碼內部細節，並不想讓外部來獲取。JavaScript 並不支援私有變數，但我們可以透過閉包做出類似的功能。如下方程式碼範例：

```js
// privateCounter 沒被法被外部修改，
// 因為閉包的關係 increment 與 decrement 可以存取到 privateCounter
// 因此 privateCounter 只能夠透過 increment 與 decrement 來改，這能有效避免被誤觸到
var counter = (function () {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function () {
      changeBy(1);
    },
    decrement: function () {
      changeBy(-1);
    },
    value: function () {
      return privateCounter;
    },
  };
})();

console.log(counter.value()); // logs 0
counter.increment();
counter.increment();
console.log(counter.value()); // logs 2
counter.decrement();
console.log(counter.value()); // logs 1
```

## 閉包缺點 — 內存洩漏

雖然說閉包很好用，但也不是沒有缺點。從記憶體的角度來看，閉包的缺點是顯而易見的，由於閉包會讓內部函式記得外部的變數，這可能會造成變數常駐在記憶體當中，如果使用過多可能會造成內存泄露 (memory leak)，需要小心使用。
{% note info%}
以下面的例子來說，`longArray`沒有被使用到，但是因為閉包的原因會一直被 addNumbers 記住。假如今天`longArray`有被使用，那就沒問題，但因為它沒有被用到但仍存在於記憶體中沒被清除，這種情況就是典型的內存洩漏。
{% endnote %}

```js
function outer() {
  const longArray = [];
  return function inner(num) {
    longArray.push(num);
  };
}
const addNumbers = outer();

for (let i = 0; i < 100000000; i++) {
  addNumbers(i);
}
```

[什麼是閉包 (Closure)？](https://www.explainthis.io/zh-hant/swe/what-is-closure)
[所有的函式都是閉包：談 JS 中的作用域與 Closure](https://blog.huli.tw/2018/12/08/javascript-closure/)